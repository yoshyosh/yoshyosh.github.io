<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Learning iOS: Week 3/7 Homework</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />
    <link href="/stylesheets/normalize.css" rel="stylesheet" />
    <link href="/stylesheets/skeleton.css" rel="stylesheet" />
    <link href="/stylesheets/base.css" rel="stylesheet" />
  </head>
  <body>
  <div class="container">
    <div id="main" role="main">
      <span class="yosh-post-meta">30 Apr 2014</span>
      <h1>Learning iOS: Week 3/7 Homework</h1>
      <p>This week, we start to learn how to use custom data in our static views. Real apps will use real data, so we finally get a chance to see how things can look and feel as we get closer to dynamic data.</p>

<h2>Creating Custom Cells</h2>

<p>This was harder than it looked (starting from scratch), but after doing it once it isn&rsquo;t so bad. 
First you start by creating a CustomTableCell class that inherits from UITableViewCell </p>

<p>Now in the xib file, adjust the height so the cell is much larger. This can be found in the right side panel under &ldquo;Show the size inspector&rdquo;, it&rsquo;s an icon that looks like a mini ruler. Then add your labels and UIImageViews. Once that&rsquo;s done, create IBOutlets in your CustomTableCell.h file.</p>

<p>Also be sure to click the table view cell, then in the right panel click &ldquo;Show the attributes inspector&rdquo; and add some name to the Identifier. I used &ldquo;myCell&rdquo;.</p>

<p>In the CustomTableCell.m file add this line of code</p>
<div class="highlight"><pre class="highlight plaintext"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier {
    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
    if (self) {
        //
    }
    return self;
}
</pre></td></tr></tbody></table></code></pre></div>
<h2>Create your TableView</h2>

<p>Create a new file that is a subclass of UITableViewController. Import your CustomTableCell.h file. Create an IBOutlet from the tableview to your TableView.m file. Then Create datasource and delegate for the table</p>
<div class="highlight"><pre class="highlight plaintext"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>self.tableView.datasource = self; 
self.tableView.delegate = self; 
</pre></td></tr></tbody></table></code></pre></div>
<p>This will give you access to the methods that power table view, so you can customize information in cells and tell the table view what/how many cells to use.</p>

<p>Uncomment and edit some of the lines below</p>
<div class="highlight"><pre class="highlight plaintext"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    // Return the number of sections.
    return 1;
}
</pre></td></tr></tbody></table></code></pre></div>
<p>This tells the tableview how many sections are in this view. Since we are listing the same items over and over we can just return 1;</p>
<div class="highlight"><pre class="highlight plaintext"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    // Return the number of rows in the section.
    return self.menuTableItems.count;
}
</pre></td></tr></tbody></table></code></pre></div>
<p>I created an array and stored it in self.menuTableItems so here I am just returning the total number of rows I need the table to have.</p>
<div class="highlight"><pre class="highlight plaintext"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
MenuTableViewCell *cell = [tableView         dequeueReusableCellWithIdentifier:@"myCell"];

if (!cell) {
[tableView registerNib:[UINib nibWithNibName:@"MenuTableViewCell" bundle:nil] forCellReuseIdentifier:@"myCell"];
cell = [tableView dequeueReusableCellWithIdentifier:@"myCell"]; 

}

cell.menuLabel.text = [NSString stringWithFormat:@"%@", self.menuTableItems[indexPath.row]];
    return cell;
}
</pre></td></tr></tbody></table></code></pre></div>
<p>This one is pretty hefty, but ultimately it is the data that tells the tableview what cell to use in each row. This is where we define our custom cell and tell the tableview how to use and reuse them. This is where you would tell the cell what image to use, what text for the labels, etc.</p>

<h2>AFNetworking setting imageview on a cell</h2>

<p>First you need to install the AFNetworking pod. Once that is done, import into your main view controller 
<code>#import &quot;UIImageView+AFNetworking.h&quot;</code></p>

<p>Then you will have access to a method that can set an imageview using urls like this for example </p>
<div class="highlight"><pre class="highlight plaintext"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>[cell.profilePic setImageWithURL:[NSURL URLWithString:@"https://pbs.twimg.com/profile_images/421403454104297472/zgjnoNmf.jpeg"]
</pre></td></tr></tbody></table></code></pre></div>
<p>It handles all the fetching, caching, and asynchronous requests for you!</p>

<h2>Creating models and fake data</h2>

<p>When creating models its important to think of the attributes of your model. For example if you are making a notification model, we need to know things like 
* The type of notification * Who it was from * A short snippet of what it is * When it was done (timestamp)</p>

<p>This will help when we need to build notification objects from the json response.</p>

<p>The <code>-(id)initWithDictionary</code> method is an instance method so it acts on an instance of notification e.g.</p>

<p><code>Notification *newNotification = [Notification alloc] initWithDictionary:....;</code></p>

<p>So this will take a dictionary and then go to the initWithDictionary method and build the object. We of course have define initWithDictionary in the implementation file Notification.m. Ultimately what it does is it sets all the values for the Notification object and returns it.</p>

<p><code>+ (NSArray *)notificationsWithArray:(NSArray *)array</code></p>

<p>This class method can be called on the class like so</p>

<p><code>[Notification notificationsWithArray:[NSArray arrayWithObjects...]]</code></p>

<p>class itself. This is because its a method/helper relevant to the Notification class we made, rather than a direct manipulation of a notification object (like changing the objects data)</p>

<p>So all this method will do is it will accept an array of dictionaries (from the json response) and then loop through each of them running <code>initWithDictionary</code> on it and adding that to a new array. Then once its done looping through all of the dictionaries it will return an array of notification objects. These objects are what we will loop through to create our different table cells.</p>

<p>Lastly the <code>fakeNotifications</code> method just creates a fake hardcoded array of dictionaries, which we then pass to notificationsWithArray to create a fake array of notifications (dummy data).</p>

<p>I didn&rsquo;t show any code so we could stay focused on the concepts that each method is trying to perform!</p>

<p>Next week we dive into animations</p>

    </div>
  </div>  
  </body>
</html>
